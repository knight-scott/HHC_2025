---
icon: material/ski
---

# Free Ski

**Difficulty**: :fontawesome-solid-snowflake:{ .red }:fontawesome-solid-snowflake:{ .red }:fontawesome-solid-snowflake:{ .red }:fontawesome-solid-snowflake:{ .red }:fontawesome-solid-snowflake:{ .red }<br/>
**Direct link**: [Free Ski](../artifacts/objectives/o25/FreeSki.exe)

## Objective

!!! question "Request"
    Go to the retro store and help Goose Olivia ski down the mountain and collect all five treasure chests to reveal the hidden flag in this classic SkiFree-inspired challenge.

??? quote "Goose Olivia"
    HONK! You know what happens to geese in a permanent winter? We can't migrate! And trust me, being stuck in one place forever isn't natural—even for someone who just discovered they can think and talk. Frosty needs to chill out... wait, that's exactly the problem!

    This game looks simple enough, doesn't it? Almost too simple. But between you and me... it seems nearly impossible to win fair and square.

    My advice? If you ain't cheatin', you ain't tryin'. wink

    Now get out there and show that mountain who's boss!

## Hints

??? tip "Extraction"
    Have you ever used [PyInstaller Extractor](https://github.com/extremecoders-re/pyinstxtractor)?

??? tip "Decompilation!"
    Many Python decompilers don't understand Python 3.13, but [Decompyle++](https://github.com/zrax/pycdc) does!

## Solution

As the hints suggested, I started with installing the PyInstaller Extractor and Decompyle++, then fumbled with getting them working, which was a challenge all it's own.<br/>
With the correct command syntax, I was finally able to use the extractor and get the expected results, which were a number of `.pyd` files, `pygame` assets and libraries, supporting `.pyc` files, and the `FreeSki.pyc`, which is the main application bytecode.

!!! tip "Virtual Environment"
    It is typically a good practice to create a virtual environment for running code such as PyInstaller Extractor. Create the virtual environment in the same directory that you will be working from.

    ```bash title="Python Virtual Environment"\
    $ python3 -m venv
    $ . ./venv/bin/activate
    ```

    This will help keep random dependencies from wreaking havok on your system.

After the extractor runs, you'll have `FreeSki.exe_extracted/` which will contain `FreeSki.pyc`. If it isn't already, now is the time to install the decompiler. The decompiler is going to take the bytecode file and decompile into readable Python source code.<br/>
As usually happens when working with a new tool, it took some time to get it figured out. I used `pycdc FreeSki.pyc > FreeSki.py` and got a partial decompiling.<br/>
I decided to shift to something more straightforward. Using `strings` on the `FreeSki.pyc` produced some key findings!

#### String Analysis Findings

```bash title="Mountain Names and Encoded Data"
Mount Snowi
Aspeni
Whistleri
M!hr9?
Mount Bakeri
3FI+h
Mount NorquayiV
Mount Erciyesi02
`PvWg
Dragonmounti
x))v
```

There appears to be a pattern of mountain name followed by strange characters, which are likely encoded treasure locations.

Since decompilation was incomplete, I extracted constants directly:

```python title="extract_constants.py"
import marshal

with open('FreeSki.pyc', 'rb') as f:
    f.read(16)  # Skip Python 3.13 header
    code = marshal.load(f)

def extract_all_consts(code_obj, indent=0):
    prefix = "  " * indent
    print(f"{prefix}=== Code Object: {code_obj.co_name} ===")
    for i, const in enumerate(code_obj.co_consts):
        if isinstance(const, type(code_obj)):
            extract_all_consts(const, indent + 1)
        else:
            print(f"{prefix}[{i}] {type(const).__name__}: {repr(const)[:100]}")

extract_all_consts(code)
```
##### Key Discoveries

- 7 mountains with encoded flags (as byte strings)
- Mountain names: Mount Snow, Aspen, Whistler, Mount Baker, Mount Norquay, Mount Erciyes, Dragonmount
- Function names: `GetTreasureLocations`, `SetFlag`

Next was understanding the flag generation algorithm.

### Disassemble Critical Functions

I was able to use `marshal` and `dis` to break down what the `SetFlag` and `GetTreasureLocations` function.

```python title="Function Disassebly"
import marshal
import dis

with open('FreeSki.pyc', 'rb') as f:
    f.read(16)
    code = marshal.load(f)

def find_and_disassemble(code_obj, target_name):
    if code_obj.co_name == target_name:
        dis.dis(code_obj)
        return True
    for const in code_obj.co_consts:
        if isinstance(const, type(code_obj)):
            if find_and_disassemble(const, target_name):
                return True
    return False

find_and_disassemble(code, "SetFlag")
find_and_disassemble(code, "GetTreasureLocations")
```

#### Algorithm Breakdown

With 
##### GetTreasureLocations Function

Generates 5 deterministic treasure locations per mountain:

```python
def get_treasure_locations(mountain_name, height):
    locations = {}
    
    # Seed RNG with CRC32 of mountain name
    random.seed(binascii.crc32(mountain_name.encode('utf-8')))
    
    prev_height = height
    prev_horiz = 0
    
    # Generate 5 treasures
    for i in range(5):
        e_delta = random.randint(200, 800)  # Elevation change
        h_delta = random.randint(int(0 - e_delta/4), int(e_delta/4))  # Horizontal change
        
        treasure_height = prev_height - e_delta
        treasure_horiz = prev_horiz + h_delta
        locations[treasure_height] = treasure_horiz
        
        prev_height = treasure_height
        prev_horiz = treasure_horiz
    
    return locations
```

##### Treasure Value Calculation

From the main game loop (line 380):

```python
treasure_value = row * mountain_width + horiz_offset
# where mountain_width = 1000
```

##### SetFlag Function

Decodes the flag using collected treasure values:

```python
def decode_flag(encoded_flag, treasure_list):
    # Step 1: Calculate product from treasure values
    product = 0
    for treasure_val in treasure_list:
        product = (product << 8) ^ treasure_val  # Left shift 8 bits, XOR
    
    # Step 2: Seed random generator with product
    random.seed(product)
    
    # Step 3: XOR each byte with random value
    decoded = []
    for byte in encoded_flag:
        r = random.randint(0, 255)
        decoded.append(chr(byte ^ r))
    
    # Step 4: Format flag
    flag_text = 'Flag: %s' % ''.join(decoded)
    return flag_text
```

With all of the information, a script can be put together that calculates the treasure location for each mountain and decodes the flag. 

!!! success "Solution Script"
    ```python title="FreeSki Solution"
    import random
    import binascii

    # Mountain data from constants
    mountains = {
        'Mount Snow': {
            'encoded_flag': b'\x90\x00\x1d\xbc\x17b\xed6S"\xb0<Y\xd6\xce\x169\xae\xe9|\xe2Gs\xb7\xfdy\xcf5\x98',
            'height': 3586,
        },
        'Aspen': {
            'encoded_flag': b'U\xd7%x\xbfvj!\xfe\x9d\xb9\xc2\xd1k\x02y\x17\x9dK\x98\xf1\x92\x0f!\xf1\\\xa0\x1b\x0f',
            'height': 11211,
        },
        'Whistler': {
            'encoded_flag': b'\x1cN\x13\x1a\x97\xd4\xb2!\xf9\xf6\xd4#\xee\xebh\xecs.\x08M!hr9?\xde\x0c\x86\x02',
            'height': 7156,
        },
        'Mount Baker': {
            'encoded_flag': b'\xac\xf9#\xf4T\xf1%h\xbe3FI+h\r\x01V\xee\xc2C\x13\xf3\x97ef\xac\xe3z\x96',
            'height': 10781,
        },
        'Mount Norquay': {
            'encoded_flag': b'\x0c\x1c\xad!\xc6,\xec0\x0b+"\x9f@.\xc8\x13\xadb\x86\xea{\xfeS\xe0S\x85\x90\x03q',
            'height': 6998,
        },
        'Mount Erciyes': {
            'encoded_flag': b'n\xad\xb4l^I\xdb\xe1\xd0\x7f\x92\x92\x96\x1bq\xca`PvWg\x85\xb21^\x93F\x1a\xee',
            'height': 12848,
        },
        'Dragonmount': {
            'encoded_flag': b'Z\xf9\xdf\x7f_\x02\xd8\x89\x12\xd2\x11p\xb6\x96\x19\x05x))v\xc3\xecv\xf4\xe2\\\x9a\xbe\xb5',
            'height': 16282,
        }
    }

    mountain_width = 1000

    def get_treasure_locations(mountain_name, height):
        """Replicate GetTreasureLocations algorithm from the bytecode"""
        locations = {}
        
        # Seed with CRC32 of mountain name (line 238)
        random.seed(binascii.crc32(mountain_name.encode('utf-8')))
        
        prev_height = height
        prev_horiz = 0
        
        # Generate 5 treasures (line 241)
        for i in range(5):
            e_delta = random.randint(200, 800)
            h_delta = random.randint(int(0 - e_delta / 4), int(e_delta / 4))
            
            # Store location
            treasure_height = prev_height - e_delta
            treasure_horiz = prev_horiz + h_delta
            locations[treasure_height] = treasure_horiz
            
            prev_height = treasure_height
            prev_horiz = treasure_horiz
        
        return locations

    def calculate_treasure_values(mountain_name, height):
        """Calculate treasure values as they would be collected in the game"""
        locations = get_treasure_locations(mountain_name, height)
        treasure_list = []
        
        # From line 380: treasure_value = row * mountain_width + horiz_offset
        for row, horiz in locations.items():
            treasure_value = row * mountain_width + horiz
            treasure_list.append(treasure_value)
        
        return treasure_list

    def decode_flag(encoded_flag, treasure_list):
        """Decode flag using the SetFlag algorithm"""
        # Calculate product (lines 304-306)
        product = 0
        for treasure_val in treasure_list:
            product = (product << 8) ^ treasure_val
        
        # Seed random (line 307)
        random.seed(product)
        
        # Decode (lines 310-312)
        decoded = []
        for byte in encoded_flag:
            r = random.randint(0, 255)
            decoded.append(chr(byte ^ r))
        
        flag_text = 'Flag: %s' % ''.join(decoded)
        return flag_text

    # Try all mountains and find the real flag
    print("="*70)
    print("SOLVING: FreeSki CTF Challenge")
    print("="*70)
    print("\nTrying each mountain to find the valid flag...\n")

    for name, data in mountains.items():
        print(f"{name}:")
        treasure_list = calculate_treasure_values(name, data['height'])
        print(f"  Treasures: {treasure_list}")
        flag = decode_flag(data['encoded_flag'], treasure_list)
        print(f"  {flag}")
        
        # Check if this looks like a real flag
        flag_lower = flag.lower()
        if any(keyword in flag_lower for keyword in ['flare', '@flare', 'flareon', '{', '}']):
            print(f"  >>> THIS IS LIKELY THE REAL FLAG! <<<")
        print()
    ```
### Key Insights

1. **"Cheating" is Required:** The game randomly selects one of 7 mountains, making it impractical to win by playing. The solution requires extracting and analyzing all mountains offline.
    
2. **Deterministic RNG:** Both treasure placement and flag decoding use seeded random number generation, making them reproducible without gameplay.
    
3. **Python 3.13 Challenges:** Most Python decompilers don't support Python 3.13. Direct bytecode analysis via `marshal` and `dis` modules was necessary.
    
4. **Layered Encoding:** The flag undergoes multiple transformations:
    
    - Stored as encrypted bytes in the executable
    - Decryption key derived from treasure locations
    - Treasure locations derived from mountain name via CRC32
    - Final XOR decryption using seeded RNG

### Tools Used

|Tool|Purpose|
|---|---|
|`pyinstxtractor.py`|Extract PyInstaller executable contents|
|`pycdc` (Decompyle++)|Attempt Python bytecode decompilation|
|Python `marshal` module|Load compiled bytecode objects|
|Python `dis` module|Disassemble bytecode to opcodes|
|`strings` command|Extract readable strings from binary|

## Response

!!! quote "Goose Olivia"
    Looks like you found your own way down that mountain... and maybe took a few shortcuts along the way. No judgment here—sometimes the clever path IS the right path. Now I'm one step closer to figuring out my own mystery. Thanks for the company, friend!
